package com.interactionfields.signaling.ot

import org.springframework.util.Assert
import java.util.concurrent.CopyOnWriteArrayList
import kotlin.math.min

class TextOperation(list: List<Any>? = null) {

    var ops = CopyOnWriteArrayList(list ?: listOf())

    /**
     * Returns the difference in length between the input and the output
     * string when this operations is applied.
     */
    fun lenDifference(): Int {
        var s = 0
        ops.forEach {
            if (it is String) {
                s += it.length
            } else if (it is Int && it < 0) {
                s += it
            }
        }
        return s
    }

    /**
     * Skips a given number of characters at the current cursor position.
     */
    fun retain(r: Int): TextOperation {
        if (r == 0) return this
        if (ops.size > 0 && ops[ops.size - 1].run { this is Int && this > 0 }) {
            ops[ops.size - 1] = ops[ops.size - 1] as Int + r
        } else {
            ops.add(r)
        }
        return this
    }

    /**
     * Inserts the given string at the current cursor position.
     */
    fun insert(s: String): TextOperation {
        if (s.isEmpty()) return this
        if (ops.size > 0 && ops[ops.size - 1] is String) {
            ops[ops.size - 1] = ops[ops.size - 1] as String + s
        } else if (ops.size > 0 && ops[ops.size - 1].run { this is Int && this < 0 }) {
            // It doesn"t matter when an operation is applied whether the operation
            // is delete(3), insert("something") or insert("something"), delete(3).
            // Here we enforce that in this case, the insert op always comes first.
            // This makes all operations that have the same effect when applied to
            // a document of the right length equal in respect to the `equals` method.
            if (ops.size > 1 && ops[ops.size - 2] is String) {
                ops[ops.size - 2] = ops[ops.size - 2] as String + s
            } else {
                val last1 = if (ops.size - 2 < 0) 0 else ops.size - 2
                ops.add(ops[last1])
                ops[last1] = s
            }
        } else {
            ops.add(s)
        }
        return this
    }

    /**
     * Deletes a given number of characters at the current cursor position.
     */
    fun delete(d: Int): TextOperation {
        var dd = d
        if (dd == 0) return this
        if (dd > 0) dd = -dd
        if (ops.size > 0 && ops[ops.size - 1].run { this is Int && this < 0 }) {
            ops[ops.size - 1] = ops[ops.size - 1] as Int + dd
        } else {
            ops.add(dd)
        }
        return this
    }

    /**
     * Apply this operation to a string, returning a new string.
     */
    fun apply(doc: String): String {
        var i = 0
        val parts = mutableListOf<Any>()
        ops.forEach {
            if (it is String && isInsert(it)) {
                parts.add(it)
            } else if (it is Int) {
                if (isRetain(it)) {
                    Assert.isTrue(
                        i + it <= doc.length,
                        "Cannot apply operation: operation is too long."
                    )
                    parts.add(doc.substring(i, i + it))
                    i += it
                } else {
                    i -= it
                    Assert.isTrue(
                        i <= doc.length,
                        "Cannot apply operation: operation is too long."
                    )
                }
            }
        }
        Assert.isTrue(
            i == doc.length,
            "Cannot apply operation: operation is too short."
        )
        return parts.joinToString(separator = "")
    }

    /**
     * Make an operation that does the opposite. When you apply an operation
     * to a string and then the operation generated by this operation, you
     * end up with your original string. This method can be used to implement
     * undo.
     */
    fun invert(doc: String): TextOperation {
        var i = 0
        val inverse = TextOperation()
        ops.forEach {
            if (it is String && isInsert(it)) {
                inverse.delete(it.length)
            } else if (it is Int) {
                if (isRetain(it)) {
                    inverse.retain(it)
                    i += it
                } else {
                    inverse.insert(doc.substring(i, i - it))
                    i -= it
                }
            }
        }
        return inverse
    }

    /**
     * Combine two consecutive operations into one that has the same effect
     * when applied to a document.
     */
    fun compose(other: TextOperation): TextOperation {
        val iterA = ops.iterator()
        val iterB = other.ops.iterator()
        val operation = TextOperation()
        var a: Any? = null
        var b: Any? = null
        var i = 1
        while (true) {
            if (a == null) a = if (iterA.hasNext()) iterA.next() else null
            if (b == null) b = if (iterB.hasNext()) iterB.next() else null
            // end condition: both operations have been processed
            if (a == null && b == null) break

            if (a is Int && isDelete(a)) {
                operation.delete(a)
                a = null
                continue
            }
            if (b is String && isInsert(b)) {
                operation.insert(b)
                b = null
                continue
            }

            Assert.notNull(a, "a=$a, b=$b, Cannot compose operations: first operation is too short")
            Assert.notNull(b, "a=$a, b=$b, Cannot compose operations: first operation is too long")

            val minLen = min(opLen(a!!), opLen(b!!))
            if (isRetain(a) && isRetain(b))
                operation.retain(minLen)
            else if (a is String && isInsert(a) && isRetain(b))
                operation.insert(a.substring(0, minLen))
            else if (isRetain(a) && isDelete(b))
                operation.delete(minLen)

            // remaining case: _is_insert(a) and _is_delete(b)
            // in this case the delete op deletes the text that has been added
            // by the insert operation and we don"t need to do anything
            shortenOps(a, b).let {
                a = it[0]
                b = it[1]
            }
        }
        return operation
    }

    companion object {

        fun isRetain(op: Any) = op is Int && op > 0
        fun isDelete(op: Any) = op is Int && op < 0
        fun isInsert(op: Any) = op is String
        fun opLen(op: Any): Int {
            if (op is String) return op.length
            if (op is Int && op < 0) return -op
            return op as Int
        }

        private fun shorten(op: Any, by: Int): Any {
            if (op is String) return op.substring(by, op.length)
            if (op is Int && op < 0) return op + by
            return (op as Int) - by
        }

        /**
         * Shorten two ops by the part that cancels each other out.
         */
        fun shortenOps(a: Any, b: Any): List<Any?> {
            val lenA = opLen(a)
            val lenB = opLen(b)
            if (lenA == lenB) return listOf(null, null)
            if (lenA > lenB) return listOf(shorten(a, lenB), null)
            return listOf(null, shorten(b, lenA))
        }

        /**
         * Transform two operations a and b to a` and b` such that b` applied
         * after a yields the same result as a` applied after b. Try to preserve
         * the intentions of the operations in the process.
         */
        fun transform(operationA: TextOperation, operationB: TextOperation): List<TextOperation> {
            val iterA = operationA.ops.iterator()
            val iterB = operationB.ops.iterator()
            val primeA = TextOperation()
            val primeB = TextOperation()
            var a: Any? = null
            var b: Any? = null

            while (true) {
                if (a == null) a = if (iterA.hasNext()) iterA.next() else null
                if (b == null) b = if (iterB.hasNext()) iterB.next() else null
                // end condition: both operations have been processed
                if (a == null && b == null) break

                if (a is String && isInsert(a)) {
                    primeA.insert(a)
                    primeB.retain(a.length)
                    a = null
                    continue
                }
                if (b is String && isInsert(b)) {
                    primeA.retain(b.length)
                    primeB.insert(b)
                    b = null
                    continue
                }

                // Two operations or an operation and a string have different lengths
                Assert.notNull(a, "Cannot compose operations: first operation is too short")
                Assert.notNull(b, "Cannot compose operations: first operation is too long")

                val minLen = min(opLen(a!!), opLen(b!!))
                if (isRetain(a) && isRetain(b)) {
                    primeA.retain(minLen)
                    primeB.retain(minLen)
                } else if (isDelete(a) && isRetain(b)) {
                    primeA.delete(minLen)
                } else if (isRetain(a) && isDelete(b)) {
                    primeB.delete(minLen)
                }

                // remaining case: _is_delete(a) and _is_delete(b)
                // in this case both operations delete the same string and we don"t
                // need to do anything
                shortenOps(a, b).let {
                    a = it[0]
                    b = it[1]
                }
            }
            return listOf(primeA, primeB)
        }
    }
}
